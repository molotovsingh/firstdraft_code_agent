Now I'll generate the unified patch implementing all the requested changes:

```diff
--- a/apps/block0_api/main.py
+++ b/apps/block0_api/main.py
@@ -1,7 +1,11 @@
-from fastapi import FastAPI, UploadFile, File, Form, HTTPException, Request
+from fastapi import FastAPI, UploadFile, File, Form, HTTPException, Request, Depends
 from fastapi.responses import JSONResponse, PlainTextResponse, Response
 from typing import List, Optional
 import os
 import uuid
+from pydantic import BaseModel, UUID4, conint, constr, Field
+import subprocess
+import hashlib
 
 from shared.db.session import SessionLocal
 from shared.db import models
@@ -119,6 +123,39 @@ def metrics():
     return Response(content=data, media_type=CONTENT_TYPE_LATEST)
 
 
+@app.get("/v0/version")
+def get_version():
+    git_sha = os.getenv("GIT_SHA")
+    if not git_sha:
+        try:
+            result = subprocess.run(
+                ["git", "rev-parse", "--short", "HEAD"],
+                capture_output=True,
+                text=True,
+                timeout=2
+            )
+            if result.returncode == 0:
+                git_sha = result.stdout.strip()
+            else:
+                git_sha = None
+        except Exception:
+            git_sha = None
+    return {"version": app.version, "git": git_sha}
+
+
+class PresignRequest(BaseModel):
+    tenant_id: UUID4
+    user_id: conint(ge=1)
+    filename: constr(min_length=1)
+    mime: constr(min_length=1) = "application/octet-stream"
+
+
+class FinalizeRequest(BaseModel):
+    tenant_id: UUID4
+    user_id: conint(ge=1)
+    key: constr(min_length=1)
+    filename: Optional[constr(min_length=1)] = None
+    mime: constr(min_length=1) = "application/octet-stream"
+
+
 @app.post("/v0/documents/upload")
 @UPLOAD_HANDLE_SECONDS.time()
 async def upload_documents(
@@ -134,51 +171,62 @@ async def upload_documents(
     db = SessionLocal()
     storage = Storage()
     out = []
-    try:
-        # Basic existence checks for tenant/user (best-effort for now)
-        tenant = db.get(models.Tenant, uuid.UUID(tenant_id))
-        if tenant is None:
-            raise HTTPException(status_code=400, detail="Unknown tenant_id")
-        user = db.get(models.User, user_id)
-        if user is None or str(user.tenant_id) != tenant_id:
-            raise HTTPException(status_code=400, detail="Invalid user for tenant")
-
-        total_bytes = 0
-        for f in files:
-            content = await f.read()
-            total_bytes += len(content)
-            sha256 = Storage.sha256_hex(content)
-            # Create document
-            doc = models.Document(
-                id=uuid.uuid4(),
-                tenant_id=tenant.id,
-                user_id=user.id,
-                case_ref=case_ref,
-                orig_filename=f.filename,
-                mime=f.content_type or "application/octet-stream",
-                bytes_sha256=sha256,
-            )
-            db.add(doc)
-            db.flush()
-
-            # Store original
-            orig_key = storage.object_key(tenant_id=str(tenant.id), sha256=sha256, version=1, filename=f.filename)
-            storage.put_object(orig_key, content, content_type=doc.mime)
-
-            # Create version with placeholder paths
-            ver = models.DocumentVersion(
-                document_id=doc.id,
-                version=1,
-                storage_uri=orig_key,
-            )
-            db.add(ver)
-            db.flush()
-
-            # Create job
-            job = models.ProcessingJob(
-                id=uuid.uuid4(),
-                document_id=doc.id,
-                status=ProcessingStatus.queued,
-            )
+    try:
+        try:
+            # Basic existence checks for tenant/user (best-effort for now)
+            tenant = db.get(models.Tenant, uuid.UUID(tenant_id))
+            if tenant is None:
+                raise HTTPException(status_code=400, detail="Unknown tenant_id")
+            user = db.get(models.User, user_id)
+            if user is None or str(user.tenant_id) != tenant_id:
+                raise HTTPException(status_code=400, detail="Invalid user for tenant")
+
+            total_bytes = 0
+            for f in files:
+                content = await f.read()
+                total_bytes += len(content)
+                sha256 = Storage.sha256_hex(content)
+                # Create document
+                doc = models.Document(
+                    id=uuid.uuid4(),
+                    tenant_id=tenant.id,
+                    user_id=user.id,
+                    case_ref=case_ref,
+                    orig_filename=f.filename,
+                    mime=f.content_type or "application/octet-stream",
+                    bytes_sha256=sha256,
+                )
+                db.add(doc)
+                db.flush()
+
+                # Store original
+                orig_key = storage.object_key(tenant_id=str(tenant.id), sha256=sha256, version=1, filename=f.filename)
+                storage.put_object(orig_key, content, content_type=doc.mime)
+
+                # Create version with placeholder paths
+                ver = models.DocumentVersion(
+                    document_id=doc.id,
+                    version=1,
+                    storage_uri=orig_key,
+                )
+                db.add(ver)
+                db.flush()
+
+                # Create job
+                job = models.ProcessingJob(
+                    id=uuid.uuid4(),
+                    document_id=doc.id,
+                    status=ProcessingStatus.queued,
+                )
+                db.add(job)
+
+                # Credit estimate (stub)
+                estimate = estimate_credits(doc.mime, len(content))
+                credit = models.Credit(
+                    tenant_id=tenant.id,
+                    user_id=user.id,
+                    delta=-estimate,
+                    reason="estimate",
+                    job_id=job.id,
+                    is_estimate=True,
+                )
             db.add(job)
 
             # Credit estimate (stub)
@@ -209,6 +257,13 @@ async def upload_documents(
         # Record bytes once per request
         UPLOAD_BYTES_TOTAL.labels(tenant_id=str(tenant.id)).inc(total_bytes)
         return JSONResponse({"documents": out})
+        except Exception as e:
+            db.rollback()
+            if isinstance(e, HTTPException):
+                raise
+            log.error("upload_documents_error", error=str(e))
+            raise HTTPException(status_code=500, detail="Internal error")
+    finally:
     finally:
         db.close()
 
@@ -390,3 +445,121 @@ def processed_json(document_id: str):
         }
     finally:
         db.close()
+
+
+@app.post("/v0/upload/presign")
+def upload_presign(request: PresignRequest):
+    db = SessionLocal()
+    storage = Storage()
+    try:
+        # Validate tenant/user
+        tenant = db.get(models.Tenant, request.tenant_id)
+        if tenant is None:
+            raise HTTPException(status_code=400, detail="Unknown tenant_id")
+        user = db.get(models.User, request.user_id)
+        if user is None or user.tenant_id != request.tenant_id:
+            raise HTTPException(status_code=400, detail="Invalid user for tenant")
+
+        # Generate unique object key
+        object_key = f"uploads/{request.tenant_id}/{uuid.uuid4()}/{request.filename}"
+        
+        # Get presigned URL
+        url = storage.presign_put_url(object_key, content_type=request.mime)
+        
+        return {
+            "object_key": object_key,
+            "url": url
+        }
+    finally:
+        db.close()
+
+
+@app.post("/v0/upload/finalize")
+def finalize_upload(request: FinalizeRequest):
+    db = SessionLocal()
+    storage = Storage()
+    try:
+        try:
+            # Validate tenant/user
+            tenant = db.get(models.Tenant, request.tenant_id)
+            if tenant is None:
+                raise HTTPException(status_code=400, detail="Unknown tenant_id")
+            user = db.get(models.User, request.user_id)
+            if user is None or user.tenant_id != request.tenant_id:
+                raise HTTPException(status_code=400, detail="Invalid user for tenant")
+
+            # Check object exists
+            if not storage.object_exists(request.key):
+                raise HTTPException(status_code=404, detail="Object not found")
+
+            # Get object bytes for SHA256
+            content = storage.get_object_bytes(request.key)
+            sha256 = hashlib.sha256(content).hexdigest()
+
+            # Check for existing document with same SHA256
+            existing_doc = db.query(models.Document).filter(
+                models.Document.tenant_id == request.tenant_id,
+                models.Document.bytes_sha256 == sha256
+            ).first()
+
+            if existing_doc:
+                # Return existing document (idempotency)
+                return {
+                    "document_id": str(existing_doc.id),
+                    "storage_uri": db.query(models.DocumentVersion).filter(
+                        models.DocumentVersion.document_id == existing_doc.id
+                    ).order_by(models.DocumentVersion.version.desc()).first().storage_uri,
+                    "credit_estimate": 0  # No new credits for duplicate
+                }
+
+            # Create new document
+            doc = models.Document(
+                id=uuid.uuid4(),
+                tenant_id=request.tenant_id,
+                user_id=request.user_id,
+                orig_filename=request.filename or request.key.split("/")[-1],
+                mime=request.mime,
+                bytes_sha256=sha256,
+            )
+            db.add(doc)
+            db.flush()
+
+            # Copy to final location
+            final_key = storage.object_key(
+                tenant_id=str(request.tenant_id),
+                sha256=sha256,
+                version=1,
+                filename=doc.orig_filename
+            )
+            storage.copy_object(request.key, final_key)
+
+            # Create version
+            ver = models.DocumentVersion(
+                document_id=doc.id,
+                version=1,
+                storage_uri=final_key,
+            )
+            db.add(ver)
+            db.flush()
+
+            # Create job
+            job = models.ProcessingJob(
+                id=uuid.uuid4(),
+                document_id=doc.id,
+                status=ProcessingStatus.queued,
+            )
+            db.add(job)
+
+            # Credit estimate
+            estimate = estimate_credits(doc.mime, len(content))
+            credit = models.Credit(
+                tenant_id=request.tenant_id,
+                user_id=request.user_id,
+                delta=-estimate,
+                reason="estimate",
+                job_id=job.id,
+                is_estimate=True,
+            )
+            db.add(credit)
+            db.commit()
+
+            # Enqueue processing
+            enqueue_process_document(str(job.id))
+
+            return {
@@ -390,3 +563,16 @@ def processed_json(document_id: str):
         }
     finally:
         db.close()
+                "document_id": str(doc.id),
+                "storage_uri": final_key,
+                "credit_estimate": estimate
+            }
+        except Exception as e:
+            db.rollback()
+            if isinstance(e, HTTPException):
+                raise
+            log.error("finalize_upload_error", error=str(e))
+            raise HTTPException(status_code=500, detail="Internal error")
+    finally:
+        db.close()
--- /dev/null
+++ b/tests/test_upload_finalize.py
@@ -0,0 +1,206 @@
+import pytest
+from fastapi.testclient import TestClient
+from unittest.mock import Mock, patch, MagicMock
+import uuid
+import hashlib
+
+
+@pytest.fixture
+def mock_storage():
+    """Mock Storage class with controllable behavior."""
+    storage = Mock()
+    storage.bucket = "test-bucket"
+    storage._object_store = {}  # In-memory object store
+    storage._exists_override = None
+    
+    def presign_put_url(key, content_type="application/octet-stream"):
+        return f"https://mock-s3.example.com/put/{key}?content_type={content_type}"
+    
+    def presign_get_url(key):
+        return f"https://mock-s3.example.com/get/{key}"
+    
+    def get_object_bytes(key):
+        if key in storage._object_store:
+            return storage._object_store[key]
+        raise Exception(f"Object not found: {key}")
+    
+    def object_key(tenant_id, sha256, version, filename):
+        return f"documents/{tenant_id}/{sha256}/v{version}/{filename}"
+    
+    def copy_object(src, dst):
+        if src in storage._object_store:
+            storage._object_store[dst] = storage._object_store[src]
+    
+    def object_exists(key):
+        if storage._exists_override is not None:
+            return storage._exists_override
+        return key in storage._object_store
+    
+    storage.presign_put_url = presign_put_url
+    storage.presign_get_url = presign_get_url
+    storage.get_object_bytes = get_object_bytes
+    storage.object_key = object_key
+    storage.copy_object = copy_object
+    storage.object_exists = object_exists
+    storage.ensure_bucket = Mock()
+    
+    return storage
+
+
+@pytest.fixture
+def mock_db():
+    """Mock database session."""
+    db = Mock()
+    db.get = Mock()
+    db.add = Mock()
+    db.flush = Mock()
+    db.commit = Mock()
+    db.rollback = Mock()
+    db.close = Mock()
+    db.execute = Mock(return_value=None)
+    db.query = Mock()
+    return db
+
+
+@pytest.fixture
+def app_client(mock_storage, mock_db):
+    """Create test client with mocked dependencies."""
+    with patch("apps.block0_api.main.Storage") as StorageMock:
+        StorageMock.return_value = mock_storage
+        with patch("apps.block0_api.main.SessionLocal") as DBMock:
+            DBMock.return_value = mock_db
+            with patch("apps.block0_api.main.enqueue_process_document"):
+                from apps.block0_api.main import app
+                client = TestClient(app)
+                yield client, mock_storage, mock_db
+
+
+def test_presign_happy_path(app_client):
+    """Test presign endpoint returns object_key and url."""
+    client, storage, db = app_client
+    
+    # Setup mock tenant and user
+    tenant_id = uuid.uuid4()
+    tenant = Mock(id=tenant_id)
+    user = Mock(id=1, tenant_id=tenant_id)
+    
+    db.get.side_effect = lambda model, id: {
+        "Tenant": tenant,
+        "User": user
+    }.get(model.__name__ if hasattr(model, "__name__") else str(model))
+    
+    response = client.post("/v0/upload/presign", json={
+        "tenant_id": str(tenant_id),
+        "user_id": 1,
+        "filename": "test.pdf",
+        "mime": "application/pdf"
+    })
+    
+    assert response.status_code == 200
+    data = response.json()
+    assert "object_key" in data
+    assert "url" in data
+    assert "test.pdf" in data["object_key"]
+    assert "https://mock-s3.example.com/put/" in data["url"]
+
+
+def test_finalize_missing_object(app_client):
+    """Test finalize endpoint returns 404 for missing object."""
+    client, storage, db = app_client
+    
+    # Setup mock tenant and user
+    tenant_id = uuid.uuid4()
+    tenant = Mock(id=tenant_id)
+    user = Mock(id=1, tenant_id=tenant_id)
+    
+    db.get.side_effect = lambda model, id: {
+        "Tenant": tenant,
+        "User": user
+    }.get(model.__name__ if hasattr(model, "__name__") else str(model))
+    
+    # Object doesn't exist
+    storage._object_store = {}
+    
+    response = client.post("/v0/upload/finalize", json={
+        "tenant_id": str(tenant_id),
+        "user_id": 1,
+        "key": "uploads/missing-key",
+        "mime": "application/pdf"
+    })
+    
+    assert response.status_code == 404
+    assert response.json()["detail"] == "Object not found"
+
+
+def test_finalize_happy_path(app_client):
+    """Test finalize creates job, negative credit estimate, returns storage_uri."""
+    client, storage, db = app_client
+    
+    # Setup mock tenant and user
+    tenant_id = uuid.uuid4()
+    tenant = Mock(id=tenant_id)
+    user = Mock(id=1, tenant_id=tenant_id)
+    
+    db.get.side_effect = lambda model, id: {
+        "Tenant": tenant,
+        "User": user
+    }.get(model.__name__ if hasattr(model, "__name__") else str(model))
+    
+    # No existing document
+    db.query.return_value.filter.return_value.first.return_value = None
+    
+    # Add test object to storage
+    test_content = b"test pdf content"
+    test_key = f"uploads/{tenant_id}/test-upload/test.pdf"
+    storage._object_store[test_key] = test_content
+    
+    response = client.post("/v0/upload/finalize", json={
+        "tenant_id": str(tenant_id),
+        "user_id": 1,
+        "key": test_key,
+        "filename": "test.pdf",
+        "mime": "application/pdf"
+    })
+    
+    assert response.status_code == 200
+    data = response.json()
+    assert "document_id" in data
+    assert "storage_uri" in data
+    assert "credit_estimate" in data
+    assert data["credit_estimate"] > 0  # Should be positive value returned, but negative delta in DB
+
+
+def test_finalize_idempotency(app_client):
+    """Test repeat finalize with same SHA returns same document."""
+    client, storage, db = app_client
+    
+    # Setup mock tenant and user
+    tenant_id = uuid.uuid4()
+    tenant = Mock(id=tenant_id)
+    user = Mock(id=1, tenant_id=tenant_id)
+    
+    db.get.side_effect = lambda model, id: {
+        "Tenant": tenant,
+        "User": user
+    }.get(model.__name__ if hasattr(model, "__name__") else str(model))
+    
+    # Add test objects with same content
+    test_content = b"duplicate content"
+    test_sha = hashlib.sha256(test_content).hexdigest()
+    key1 = f"uploads/{tenant_id}/upload1/file1.pdf"
+    key2 = f"uploads/{tenant_id}/upload2/file2.pdf"
+    storage._object_store[key1] = test_content
+    storage._object_store[key2] = test_content
+    
+    # Existing document with same SHA
+    existing_doc_id = uuid.uuid4()
+    existing_doc = Mock(id=existing_doc_id, bytes_sha256=test_sha)
+    existing_version = Mock(storage_uri="documents/existing/uri")
+    
+    def query_side_effect(*args, **kwargs):
+        mock_query = Mock()
+        mock_query.filter.return_value.first.return_value = existing_doc
+        mock_query.filter.return_value.order_by.return_value.first.return_value = existing_version
+        return mock_query
+    
+    db.query.side_effect = query_side_effect
+    
+    response = client.post("/v0/upload/finalize", json={
+        "tenant_id": str(tenant_id),
+        "user_id": 1,
+        "key": key2,
+        "mime": "application/pdf"
+    })
+    
+    assert response.status_code == 200
+    data = response.json()
+    assert data["document_id"] == str(existing_doc_id)
+    assert data["credit_estimate"] == 0  # No new credits for duplicate
```
