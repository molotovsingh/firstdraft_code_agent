>>>PATCH

```diff
--- a/shared/storage/s3.py
+++ b/shared/storage/s3.py
@@ -89,6 +89,22 @@ class Storage:
                 pass
         return self.client.presigned_get_object(self.bucket, key, expires=timedelta(seconds=expiry))
 
+    def presign_put_url_internal(self, key: str, expiry: int = 3600) -> str:
+        """Return presigned PUT URL using internal endpoint (no S3_PUBLIC_ENDPOINT_URL)."""
+        return self.client.presigned_put_object(self.bucket, key, expires=timedelta(seconds=expiry))
+
+    def presign_get_url_internal(self, key: str, expiry: int = 600) -> str:
+        """Return presigned GET URL using internal endpoint (no S3_PUBLIC_ENDPOINT_URL)."""
+        return self.client.presigned_get_object(self.bucket, key, expires=timedelta(seconds=expiry))
+
     # --- Offline SigV4 presign for public endpoint ---
     def _offline_presign(self, method: str, key: str, expiry: int, public_endpoint: str) -> str:
         # Inputs
```

```diff
--- a/apps/block0_api/main.py
+++ b/apps/block0_api/main.py
@@ -343,7 +343,7 @@ class PresignRequest(BaseModel):
 
 
 @app.post("/v0/uploads/presign")
-def presign_upload(payload: PresignRequest):
+def presign_upload(payload: PresignRequest, request: Request):
     """
     Create a presigned PUT URL for direct upload to S3/MinIO.
     No DB writes here. Returns object_key and URL.
@@ -359,7 +359,12 @@ def presign_upload(payload: PresignRequest):
     object_key = f"{tenant_id}/{rand_sha[:2]}/{rand_sha}/v1/orig/{filename}.{suffix}"
 
     storage = Storage()
-    url = storage.presign_put_url(object_key, expiry=3600)
+    
+    # Check X-Internal-Network header to decide presign method
+    if request.headers.get("X-Internal-Network"):
+        url = storage.presign_put_url_internal(object_key, expiry=3600)
+    else:
+        url = storage.presign_put_url(object_key, expiry=3600)
     log.info("presign_created", tenant_id=tenant_id, user_id=int(payload.user_id), object_key=object_key)
     return JSONResponse({"object_key": object_key, "url": url, "expiry": 3600, "mime": mime})
 
```

```diff
--- a/scripts/smoke_finalize.py
+++ b/scripts/smoke_finalize.py
@@ -55,6 +55,15 @@ def main():
 
     # Step 1: Get presigned URL
     print("1. Getting presigned upload URL...")
+    
+    # Prepare headers for presign request
+    headers = {}
+    if os.getenv("PRESIGN_INTERNAL") == "1":
+        headers["X-Internal-Network"] = "1"
+        print("   Using internal network presign mode")
+    else:
+        print("   Using standard presign mode")
+    
     presign_resp = _retry(lambda: requests.post(
         f"{API_BASE}/v0/uploads/presign",
         json={
@@ -64,6 +73,7 @@ def main():
             "mime": mime,
         },
         timeout=30,
+        headers=headers,
     ))
     presign_resp.raise_for_status()
     presign_data = presign_resp.json()
```

```diff
--- a/scripts/smoke_in_network.sh
+++ b/scripts/smoke_in_network.sh
@@ -10,6 +10,7 @@ IMAGE=${IMAGE:-infra_api:latest}
 echo "Running smoke inside network: $NETWORK using image: $IMAGE"
 docker run --rm --network "$NETWORK" \
   --env API_BASE='http://api:8000' \
+  --env PRESIGN_INTERNAL='1' \
   --env TENANT_ID='11111111-1111-1111-1111-111111111111' \
   --env USER_ID='1' \
   "$IMAGE" python scripts/smoke_finalize.py
```

<<<PATCH
