This repository appears to be a document processing pipeline with a web API, a background worker, and shared libraries for common functionality.

**Repository Map:**

*   **Services:**
    *   `apps/block0_api`: A FastAPI-based web application that serves the API and a simple frontend.
    *   `apps/block0_worker`: A Celery-based worker for asynchronous tasks like OCR processing.
*   **Shared Libraries (`shared/`):**
    *   `config`: Application settings and configuration.
    *   `db`: SQLAlchemy models, database session management.
    *   `llm_service`: Likely for interacting with a language model.
    *   `ocr`: Adapters for different OCR engines (Tesseract, OCRmyPDF).
    *   `quality`: Text normalization and quality metrics.
    *   `storage`: S3/MinIO storage backend.
*   **Tests (`tests/`):**
    *   Pytest is used for testing. The tests cover the API, quality metrics, and basic UI and upload functionality.

**Dependencies:**

The project uses a mix of web, database, and data processing libraries. Key dependencies include FastAPI, SQLAlchemy, Celery, Redis, MinIO, and OCR-related tools like Tesseract.

**Top 5 Risk/Complexity Hotspots:**

1.  **Shared Library (`shared/`):** The `shared` directory is a critical component. Any changes here could have cascading effects on both the API and the worker.
2.  **Database Migrations (`alembic/`):** Database schema changes are managed by Alembic. Incorrect migrations can lead to data loss or corruption.
3.  **OCR Processing (`shared/ocr/`):** OCR is inherently complex and can be a source of errors and performance bottlenecks. The multiple adapters add to the complexity.
4.  **Quality Metrics (`shared/quality/`):** The quality metrics and normalization logic can be complex and may require domain expertise to maintain and extend.
5.  **LLM Integration (`shared/llm_service/`):** Interacting with external language models can introduce latency and unreliability.

**5 Quick Wins for Reliability/UX:**

1.  **Add comprehensive health checks:** The API has a health check, but the worker does not. Adding a health check to the worker would improve monitoring.
2.  **Improve UI feedback:** The frontend could provide more feedback to the user during file uploads and processing.
3.  **Add input validation:** Stricter input validation in the API can prevent errors and improve security.
4.  **Increase test coverage:** Adding more tests, especially for the OCR and quality metric components, would improve reliability.
5.  **Standardize logging:** Consistent, structured logging across all services would make debugging easier.

**5 Mid-Term Improvements:**

1.  **Refactor the `shared` library:** As the project grows, the `shared` library could become a monolith. Breaking it down into smaller, more focused libraries would improve maintainability.
2.  **Introduce a more robust testing strategy:** Implementing contract testing between the API and the worker would ensure that they can evolve independently without breaking each other.
3.  **Enhance the CI/CD pipeline:** The current pipeline is basic. Adding automated testing, linting, and deployment stages would improve the development workflow.
4.  **Implement distributed tracing:** With multiple services, tracing requests as they flow through the system would be invaluable for debugging and performance analysis.
5.  **Adopt a modern frontend framework:** The current frontend is based on simple HTML templates. Migrating to a modern framework like React or Vue.js would enable a more interactive and user-friendly experience.
